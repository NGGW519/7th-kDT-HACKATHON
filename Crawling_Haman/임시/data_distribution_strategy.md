# 데이터 분배 전략: MySQL(관계형) vs. ChromaDB(벡터)

## 1. 개요

이 문서는 함안군 데이터 프로젝트의 하이브리드 데이터베이스 아키텍처를 정의합니다. 지능형 챗봇과 정보 서비스를 구축하기 위해, **사실 정보의 원본 저장소(MySQL)**와 **의미 기반 검색 엔진(ChromaDB)**의 역할을 명확히 구분하고, 데이터가 두 시스템 간에 어떻게 분배되고 활용되는지에 대한 전략을 설명합니다.

## 2. 핵심 아키텍처 원칙

*   **MySQL (관계형 DB)는 '원본 데이터 저장소'이다.**
    *   모든 데이터의 최초이자 최종적인 **마스터 데이터(Master Data)**는 MySQL에 저장됩니다. 데이터의 추가, 수정, 삭제는 MySQL을 기준으로 이루어집니다. 즉, 우리 시스템의 **'단일 진실 공급원(Single Source of Truth)'**입니다.

*   **ChromaDB (벡터 DB)는 '검색을 위한 색인(Index)'이다.**
    *   ChromaDB는 원본 데이터를 직접 저장하지 않습니다. 대신, MySQL에 저장된 텍스트 데이터의 **'의미(Vector)'**를 저장하여, 사용자가 자연어로 질문했을 때 가장 관련성 높은 원본 데이터가 무엇인지 빠르게 찾아주는 **검색 엔진** 역할을 수행합니다.

## 3. 데이터 분배 계획

### 3.1. MySQL (관계형 DB)에 저장할 데이터

**결론: 모든 CSV 파일의 모든 구조화된 데이터를 저장합니다.**

MySQL은 프로젝트의 모든 원본 데이터를 저장하는 근간입니다. 아래 표와 같이 각 CSV 파일의 내용은 우리가 설계한 테이블에 매핑되어 저장되어야 합니다.

| 원본 CSV 파일 | 저장될 MySQL 테이블 | 주요 저장 정보 | 역할 | 
| :--- | :--- | :--- | :--- |
| `맛집리스트`, `카페리스트`, `병의원정보` 등 장소 관련 파일 전부 | `locations` | 이름, 주소, 전화번호, **좌표(POINT)**, 카테고리 | 사실 기반 정보의 핵심. 필터링, 지도 표시의 기준. | 
| `인물`, `전설`, `공공미술 현황` | `culture` | 이름, 제목, **상세 이야기(TEXT)**, 관련 장소 | 문화 콘텐츠의 원본 텍스트 저장. | 
| `자원봉사단체현황` | `organizations` | 단체명, 대표, 회원수 | 단체 정보의 원본. | 
| (크롤링된 리뷰 데이터) | `reviews` | **리뷰 내용(TEXT)**, 평점, 작성자 | 사용자의 생생한 경험 데이터 원본. | 
| (기획된 미션 데이터) | `missions` | 미션 제목, **상세 설명(TEXT)**, 보상 | 서비스 기획 콘텐츠의 원본. | 

**왜 MySQL에 모든 것을 저장하는가?**
*   **데이터 무결성**: 데이터 간의 관계(예: 장소-리뷰)를 보장하고, 정보의 중복과 누락을 방지합니다.
*   **정확한 검색**: "함안군청의 전화번호는?"과 같은 사실 기반의 명확한 질문에 가장 빠르고 정확하게 답변할 수 있습니다.
*   **데이터 관리**: 모든 정보가 중앙에 모여 있어 수정, 삭제, 백업 등 관리가 용이합니다.

### 3.2. ChromaDB (벡터 DB)에 저장할 데이터

**결론: MySQL에 저장된 텍스트(TEXT) 데이터의 '의미(Vector)'를 저장합니다.**

ChromaDB에는 실제 텍스트가 아닌, 텍스트를 AI 모델이 이해할 수 있는 숫자 배열(벡터)로 변환한 값을 저장합니다. 이때, 어떤 원본 데이터의 벡터인지 알 수 있도록 **MySQL의 테이블명과 ID를 함께 저장**하는 것이 핵심입니다.

| 벡터화할 원본 데이터 (MySQL) | ChromaDB 저장 정보 | 역할 및 검색 예시 | 
| :--- | :--- | :--- | 
| `locations` 테이블의 `name`, `description` | `embedding`: (이름+설명 벡터)<br>`metadata`: `{ "source": "locations", "id": 123 }` | **장소 추천**<br>"아이들과 갈만한 조용한 공원 추천해줘" | 
| `culture` 테이블의 `title`, `story` | `embedding`: (제목+이야기 벡터)<br>`metadata`: `{ "source": "culture", "id": 45 }` | **스토리텔링 검색**<br>"함안의 슬픈 사랑 전설에 대해 알려줘" | 
| `reviews` 테이블의 `content` | `embedding`: (리뷰 내용 벡터)<br>`metadata`: `{ "source": "reviews", "id": 789 }` | **감성/분위기 기반 검색**<br>"여기 음식은 맛있는데 직원이 불친절하다는 리뷰가 있나요?" | 
| `missions` 테이블의 `title`, `description` | `embedding`: (미션 제목+설명 벡터)<br>`metadata`: `{ "source": "missions", "id": 12 }` | **미션 추천**<br>"사진 찍기 좋은 미션이 있을까?" | 

**왜 텍스트의 '의미'만 따로 저장하는가?**
*   **유연한 검색**: "분위기 좋은" 처럼 데이터에 없는 추상적인 키워드로도 검색이 가능해집니다.
*   **자연어 이해**: 사용자가 문법에 맞지 않거나 구어체로 질문해도 의도를 파악하여 가장 관련성 높은 정보를 찾아줍니다.
*   **추천 시스템**: 특정 장소나 이야기에 '비슷한' 다른 장소나 이야기를 추천하는 기능의 기반이 됩니다.

## 4. 전체 데이터 흐름 요약

```
1. 데이터 수집
   [CSV 파일들] --(ETL 작업)--> [ MySQL (모든 원본 데이터 저장) ]

2. 검색 인덱스 생성
   [ MySQL ] --(AI 임베딩 모델)--> [ ChromaDB (텍스트의 의미 벡터 저장) ]

3. 챗봇의 사용자 질문 처리
   [사용자 질문] -> [챗봇] -> [ChromaDB (의미가 가장 비슷한 데이터 ID 검색)]
                                    ↓
                [챗봇] <- [MySQL (ID로 상세 정보 조회)] -> [최종 답변 생성]
```
